# Technical Documentation

## Configuration

To configure the environment variables for use with the `render_cdk`, you need to set the `API_KEY` environment variable. You can do this by creating a `.env` file in the root of your project with the following content:

```.env
API_KEY=rnd_xxxxXXXXxxxxXXXXxxxXX
```

Make sure to replace `rnd_xxxxXXXXxxxxXXXXxxxXX` with your actual Render API key.

### Installation

Add `render_cdk` to your `Cargo.toml`:

```toml
[dependencies]
render_cdk = "0.0.7"
```

* _Alternatively_, running at the `cargo add render_cdk` **root** of your project will also add **render_cdk** to your project.

### Usage Examples

Here are basic examples of how to use the `render_cdk` crate to interact with [Render Cloud](https://render.com/):

### 1. Querying for Deployed Services

#### List All Services

```rust
use render_cdk::environment_management::prelude::*;
use render_cdk::resource_management::prelude::*;
use tokio::main;

#[main]
async fn main() {
    let services = ServiceManager::list_all_services("10").await;
    // Process the services as needed.
}` 

#### List All Services by Name and Type

```rust
use render_cdk::environment_management::prelude::*;
use render_cdk::resource_management::prelude::*;
use tokio::main;

#[main]
async fn main() {
    let services = ServiceManager::find_service_by_name_and_type("my_api", "web_service").await;
    // Process the services as needed.
}
```

#### List All Services by Region

```rust
use render_cdk::environment_management::prelude::*;
use render_cdk::resource_management::prelude::*;
use tokio::main;

#[main]
async fn main() {
    let services = ServiceManager::find_service_by_region("oregon", "10").await;
    // Process the services as needed.
}
```

#### List All Services by Environment

```rust
use render_cdk::environment_management::prelude::*;
use render_cdk::resource_management::prelude::*;
use tokio::main;

#[main]
async fn main() {
    let services = ServiceManager::find_service_by_environment("image", "10").await;
    // Process the services as needed.
}
```

### 2. Using Simple .conf Files for Resource Provisioning

* `.conf` files offer a convenient alternative to _programmatic resource provisioning_, allowing you to **define** and **manage** resources through _simple_ configuration settings.

### Configuration File Example

The following is a _sample configuration__ file. This will be used to provision a managed **Postgres** instance and a managed **Redis** instance.

* `[database]` section specifies the configuration for a managed Postgres instance.

* The `name` and `user` fields should be filled with the desired **database name** and **user**.
`enable_high_availability` indicates whether high availability should be enabled.
`plan` specifies the pricing plan for the instance, and `version` indicates the Postgres version.

```conf
[database]
name = ""                  # Replace with the desired database name 
user = ""                  # Replace with the desired database user
enable_high_availability = false  # Set to true to enable high availability
plan = "free"              # Pricing plan for the database instance
version = "11"             # Postgres version
```

**_Note_** Blank fields will be  **autogenerated**.

* `[redis]` section specifies the configuration for a managed **Redis** instance.
 `plan` specifies the pricing plan for the instance.

```conf
[redis]
plan = "free"              # Pricing plan for the Redis instance` 
```

### Explanation

* **[database] Section**:

  * **name**: The name of the Postgres database.
  * **user**: The user for the Postgres database.
  * **enable_high_availability**: Boolean value to enable or disable high availability for the database.
  * **plan**: The pricing plan for the Postgres instance. Options may include "starter", "standard", "premium", etc.

    > **_Note_** **free** plan will result in failed deployments.

  * **version**: The version of Postgres to be used.
* **[redis] Section**:

  * **plan**: The pricing plan for the Redis instance. Options may include "free", "standard", "premium", etc.
    > **_Note_** **free** plan will result in failed deployments.

This configuration file allows you to easily set up _**managed database**_ and _**caching**_ services with _specific plans_ and options suited to your project's needs.

```rust
`use render_cdk::config;

fn main() {
    let config = config::Conf::read_configuration_file().unwrap();
    println!("Sample Configuration: {:?}\n", config);
}
```

### 3. Retrieve a List of Authorized 'Users'

```rust
use render_cdk::environment_management::prelude::*;
use render_cdk::resource_management::prelude::*;
use tokio::main;

#[main]
async fn main() {
    let authorized_users = Owner::list_authorized_users("irfanghat@gmail.com", "100")
        .await
        .unwrap();

    // [DEBUG] logs.
    // println!("Owner Info.: {:?}\n", authorized_users);

    // Retrieving the <owner_id>. This is used to tie a <resource> to the user who created it.
    let owner_id = authorized_users
        .get(0)
        .map(|owner_response| owner_response.owner.id.clone())
        .expect("No authorized users found.");
}
```

### 4. Creating Services

```rust
use render_cdk::environment_management::prelude::*;
use render_cdk::resource_management::{self, models::prelude::*, prelude::*};
use tokio::main;

#[main]
async fn main() {
    let authorized_users = Owner::list_authorized_users("irfanghat@gmail.com", "100")
        .await
        .unwrap();

    let owner_id = authorized_users
        .get(0)
        .map(|owner_response| owner_response.owner.id.clone())
        .expect("No authorized users found.");

    let deployment_config = template::Template {
        type_: "static_site".to_owned(), // Options ->
        name: "test_deployment".to_owned(),
        owner_id,
        repo: "https://github.com/lexara-prime-ai/SAMPLE_STATIC_SITE".to_owned(),
        auto_deploy: "yes".to_owned(), // By default, Render automatically deploys your service whenever you update its code or configuration.
        branch: None,
        image: None,
        build_filter: None,
        root_dir: "./public".to_owned(),
        env_vars: vec![],
        secret_files: vec![],
        service_details: Some(ServiceDetails {
            build_command: None, // Render runs this command to build your app before each deploy e.g npm run build, yarn build.
            headers: vec![],
            publish_path: Some("./".to_owned()), // This will translate to /public/
            pull_request_previews_enabled: Some("yes".to_owned()),
            routes: vec![],
        }),
    };

    let service = ServiceManager::create_service(deployment_config)
        .await
        .unwrap();
}
```